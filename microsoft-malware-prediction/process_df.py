import pandas as pd
import glob
import shutil
import sys
import numpy as np
from IPython.display import display, HTML
import matplotlib.pyplot as plt
import math
from time import time
from sklearn.impute import SimpleImputer
from sklearn.naive_bayes import GaussianNB
from sklearn.metrics import accuracy_score
from sklearn.metrics import fbeta_score
from sklearn.model_selection import train_test_split
import pickle
from scipy.special import boxcox1p
import os
from past.builtins import execfile
from scipy.stats import norm, skew

def include(filename):
    if os.path.exists(filename):
        execfile(filename)

def train_predict(learner, sample_size, X_train, y_train, X_test, y_test): 
    '''
    inputs:
       - learner: the learning algorithm to be trained and predicted on
       - sample_size: the size of samples (number) to be drawn from training set
       - X_train: features training set
       - y_train: income training set
       - X_test: features testing set
       - y_test: income testing set
    '''
    
    results = {}
    
    # TODO: Fit the learner to the training data using slicing with 'sample_size'
    start = time() # Get start time
    learner.fit(X_train[:sample_size], y_train[:sample_size])
    end = time() # Get end time
    print("Learning done")
    
    # TODO: Calculate the training time
    results['train_time'] = end - start
        
    # TODO: Get the predictions on the test set,
    #       then get predictions on the first 300 training samples
    start = time() # Get start time
    predictions_test = learner.predict(X_test)
    predictions_train = learner.predict(X_train)
    end = time() # Get end time
    print("Prediction done")
       
    # TODO: Calculate the total prediction time
    results['pred_time'] = end - start
            
    # TODO: Compute accuracy on the first 300 training samples
    results['acc_train'] = accuracy_score(y_train, learner.predict(X_train))
        
    # TODO: Compute accuracy on test set
    results['acc_test'] = accuracy_score(y_test, learner.predict(X_test))
    
    # TODO: Compute F-score on the the first 300 training samples
    results['f_train'] = fbeta_score(y_train, learner.predict(X_train), beta=0.5)
        
    # TODO: Compute F-score on the test set
    results['f_test'] = fbeta_score(y_test, learner.predict(X_test), beta=0.5)
       
    # Success
    print("{} trained on {} samples.".format(learner.__class__.__name__, sample_size))
    print(results)
        
    # Return the results
    return learner

def break_and_get_part(value, position):
    return value.split(".")[position]

def break_and_get_part_osbuildlab(value, position):
    if position < 4:
        try:
            return value.split(".")[position]
        except:
            return math.nan
    elif position == 4:
        try:
            return value.split(".")[4].split('-')[0]
        except:
            return math.nan
    elif position == 5:
        try:
            return value.split(".")[4].split('-')[1]
        except:
            return math.nan

def process_df(df):
    drop_list = ['PuaMode',
                 'Census_ProcessorClass',
                 'DefaultBrowsersIdentifier',
                 'Census_IsFlightingInternal',
                 'ProductName', 
                 'Platform', 
                 'Processor', 
                 'OsPlatformSubRelease',
                 'SkuEdition', 
                 'SmartScreen', 
                 'Census_MDC2FormFactor',
                 'Census_DeviceFamily', 
                 'Census_PrimaryDiskTypeName',
                 'Census_ChassisTypeName', 
                 'Census_PowerPlatformRoleName',
                 'Census_InternalBatteryType', 
                 'Census_OSArchitecture',
                 'Census_OSBranch', 
                 'Census_OSEdition', 
                 'Census_OSSkuName',
                 'Census_OSInstallTypeName', 
                 'Census_OSWUAutoUpdateOptionsName',
                 'Census_GenuineStateName', 
                 'Census_ActivationChannel',
                 'Census_FlightRing', 
                 ]
    df.drop(drop_list, axis=1, inplace=True)
    drop_list = []
    print("Drop 1 done")

    
    # Blindly replace all nan with 0.
    # This has to be change later.
    df = df.replace(np.nan, 0)
    print("Replace done")
    
    df['EngineVersion_0'] = df['EngineVersion'].apply(break_and_get_part, position=0)
    df['EngineVersion_1'] = df['EngineVersion'].apply(break_and_get_part, position=1)
    df['EngineVersion_2'] = df['EngineVersion'].apply(break_and_get_part, position=2)
    df['EngineVersion_3'] = df['EngineVersion'].apply(break_and_get_part, position=3)
    print("Something 1 done")
    
    df['AppVersion_0'] = df['AppVersion'].apply(break_and_get_part, position=0)
    df['AppVersion_1'] = df['AppVersion'].apply(break_and_get_part, position=1)
    df['AppVersion_2'] = df['AppVersion'].apply(break_and_get_part, position=2)
    df['AppVersion_3'] = df['AppVersion'].apply(break_and_get_part, position=3)
    print("Something 2 done")
    
    df['AvSigVersion_0'] = df['AvSigVersion'].apply(break_and_get_part, position=0)
    df['AvSigVersion_1'] = df['AvSigVersion'].apply(break_and_get_part, position=1)
    df['AvSigVersion_2'] = df['AvSigVersion'].apply(break_and_get_part, position=2)
    df['AvSigVersion_3'] = df['AvSigVersion'].apply(break_and_get_part, position=3)
    print("Something 3 done")
    
    drop_list.append('EngineVersion')
    drop_list.append('AppVersion')
    drop_list.append('AvSigVersion')
    
    df['OsVer_0'] = df['OsVer'].apply(break_and_get_part, position=0)
    df['OsVer_1'] = df['OsVer'].apply(break_and_get_part, position=1)
    df['OsVer_2'] = df['OsVer'].apply(break_and_get_part, position=2)
    df['OsVer_3'] = df['OsVer'].apply(break_and_get_part, position=3)
    drop_list.append('OsVer')
    print("Something 4 done")
    
    df['OsBuildLab_0'] = df['OsBuildLab'].apply(break_and_get_part_osbuildlab, position=0)
    df['OsBuildLab_1'] = df['OsBuildLab'].apply(break_and_get_part_osbuildlab, position=1)
    df['OsBuildLab_2'] = df['OsBuildLab'].apply(break_and_get_part_osbuildlab, position=2)
    df['OsBuildLab_3'] = df['OsBuildLab'].apply(break_and_get_part_osbuildlab, position=3)
    df['OsBuildLab_4'] = df['OsBuildLab'].apply(break_and_get_part_osbuildlab, position=4)
    df['OsBuildLab_5'] = df['OsBuildLab'].apply(break_and_get_part_osbuildlab, position=5)
    drop_list.append('OsBuildLab')
    print("Something 5 done")
    
    # df.loc[df.SmartScreen == 'off', 'SmartScreen'] = "Off"
    # df.loc[df.SmartScreen == 'on', 'SmartScreen'] = "On"
    # df.loc[df.SmartScreen == 'OFF', 'SmartScreen'] = "Off"
    # df.loc[df.SmartScreen == 'requireAdmin', 'SmartScreen'] = "RequireAdmin"
    # df.loc[df.SmartScreen == 'Promt', 'SmartScreen'] = "Prompt"
    # df.loc[df.SmartScreen == 'prompt', 'SmartScreen'] = "Prompt"
    # df.loc[df.SmartScreen == 'warn', 'SmartScreen'] = "Warn"
    # df.loc[df.SmartScreen == 'requireadmin', 'SmartScreen'] = "RequireAdmin"
    print("Something 6 done")
    
    df['Census_OSVersion_0'] = df['Census_OSVersion'].apply(break_and_get_part, position=0)
    df['Census_OSVersion_1'] = df['Census_OSVersion'].apply(break_and_get_part, position=1)
    df['Census_OSVersion_2'] = df['Census_OSVersion'].apply(break_and_get_part, position=2)
    df['Census_OSVersion_3'] = df['Census_OSVersion'].apply(break_and_get_part, position=3)
    drop_list.append('Census_OSVersion')
    print("Something 7 done")
    
    drop_list.append('EngineVersion_0')
    drop_list.append('EngineVersion_1')
    drop_list.append('AppVersion_0')
    drop_list.append('AvSigVersion_3')
    print("Something 8 done")

    df.drop(drop_list, axis=1, inplace=True)
    drop_list = []
    print("Drop 2 done")

    drop_list = ['EngineVersion_2', 
                 'EngineVersion_3',
                 'AppVersion_1', 
                 'AppVersion_2', 
                 'AppVersion_3', 
                 'AvSigVersion_0',
                 'AvSigVersion_1', 
                 'AvSigVersion_2', 
                 'OsVer_0', 
                 'OsVer_1', 
                 'OsVer_2',
                 'OsVer_3', 
                 'OsBuildLab_0', 
                 'OsBuildLab_1', 
                 'OsBuildLab_2',
                 'OsBuildLab_3', 
                 'OsBuildLab_4', 
                 'OsBuildLab_5', 
                 'Census_OSVersion_0',
                 'Census_OSVersion_1', 
                 'Census_OSVersion_2', 
                 'Census_OSVersion_3'
                 ]
    df.drop(drop_list, axis=1, inplace=True)
    drop_list = []
    print("Drop 3 done")

    skewed_features = df.apply(lambda x: skew(x.dropna())).sort_values(ascending=False)
    skewness = pd.DataFrame({'Skew': skewed_features})
    skewness = skewness[abs(skewness) > 0.75]
    print("Skew done")

    skewed_features = skewness.index
    lam = 0.15
    for feat in skewed_features:
        df[feat] = boxcox1p(df[feat], lam)
    print("BoxCox done")
    
    return df

